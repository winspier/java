# Домашние задания по Java

Для того, чтобы протестировать программу:

* Скачайте
  * тесты
    * [базовый модуль](https://www.kgeorgiy.info/git/geo/java-advanced-2025/src/branch/master/artifacts/info.kgeorgiy.java.advanced.base.jar)
    * [тестовый модуль](https://www.kgeorgiy.info/git/geo/java-advanced-2025/src/branch/master/artifacts/info.kgeorgiy.java.advanced.base.jar) (свой для каждого ДЗ)
  * [библиотеки](https://www.kgeorgiy.info/git/geo/java-advanced-2025/src/branch/master/artifacts/info.kgeorgiy.java.advanced.base.jar)
* Откомпилируйте решение домашнего задания
* Протестируйте домашнее задание
  * Текущая директория должна:
    * содержать все скачанные `.jar` файлы;
    * содержать скомпилированное решение;
    * __не__ содержать скомпилированные самостоятельно тесты.
  * Запустите тесты:
    `java -cp . -p . -m <тестовый модуль> <вариант> <полное имя класса>`
  * Пример для простого варианта ДЗ-1:
    `java -cp . -p . -m info.kgeorgiy.java.advanced.walk Walk <полное имя класса>`
## Домашнее задание 1. Обход файлов

Разработайте класс `Walk`, осуществляющий подсчет хэш-сумм файлов.

**Формат запуска:**  
`java Walk <входной файл> <выходной файл>`

- Входной файл содержит список файлов, которые требуется обойти.
- Выходной файл должен содержать по одной строке для каждого файла в формате:  
  `<шестнадцатеричная хэш-сумма> <путь к файлу>`

- Используйте последние 64 бита SHA-256 (поддержка есть в стандартной библиотеке).
- Если при чтении файла возникают ошибки — укажите в качестве хэш-суммы все нули.
- Кодировка файлов — UTF-8.
- Размеры файлов могут превышать размер оперативной памяти.

### Пример

**Входной файл:**
```
samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file
```

**Выходной файл:**
```
6b86b273ff34fce1 samples/1
6b51d431df5d7f14 samples/12
a665a45920422f9d samples/123
03ac674216f3e15c samples/1234
6b86b273ff34fce1 samples/1
40aff2e9d2d8922e samples/binary
0000000000000000 samples/no-such-file
```

### Сложный вариант: `RecursiveWalk`
- Рекурсивный обход директорий.
- Формат входа и выхода аналогичен, но входной файл может содержать директории.

**Пример:**

**Входной файл:**
```
samples/binary
samples
samples/no-such-file
```

**Выходной файл:**
```
40aff2e9d2d8922e samples/binary
6b86b273ff34fce1 samples/1
6b51d431df5d7f14 samples/12
a665a45920422f9d samples/123
03ac674216f3e15c samples/1234
40aff2e9d2d8922e samples/binary
0000000000000000 samples/no-such-file
```

**Обратите внимание на:**
- Обработку исключений и диагностику ошибок.
- Корректное завершение программы.
- Работа с вводом-выводом без утечек ресурсов.
- Повторное использование кода.
- Код должен быть в пакете `info.kgeorgiy.ja.фамилия.walk`.

## Домашнее задание 2. Множество на массиве

Разработайте класс `ArraySet`, реализующий неизменяемое упорядоченное множество.

- Простой вариант: реализуйте интерфейс `SortedSet`.
- Сложный вариант: `NavigableSet`.
- Операции должны быть максимально эффективны по асимптотике.

**Обратите внимание на:**
- Использование стандартных коллекций.
- Избавление от повторяющегося кода.
- Отсутствие `unchecked warnings` и `@SuppressWarnings("unchecked")`, если они не нужны.

## Домашнее задание 3. Студенты

Разработайте класс `StudentDB`, реализующий интерфейс:

- `StudentQuery` (простой вариант)
- `GroupQuery` (сложный вариант)

Каждый метод — один оператор (длинные разбивайте на строки).

**Обратите внимание на:**
- Использование лямбд и стримов.
- Избавление от повторяющегося кода.

## Домашнее задание 4. Сплитераторы и коллекторы

Разработайте класс `Lambda`.

### Простой вариант (`EasyLambda`):
- Сплитераторы: бинарные, бинарные с известным размером, k-ичные деревья.
- Коллекторы: первый, последний, средний элемент; общий префикс и суффикс строк.

### Сложный вариант (`HardLambda`):
- Сплитераторы деревьев над списками.
- Коллекторы: n-ый элемент, первые и последние n элементов.

**Обратите внимание:**
- На характеристики сплитераторов.
- Повторное использование кода.

## Домашнее задание 5. Implementor

Класс `Implementor` генерирует реализации интерфейсов и классов.

### Запуск:
```
java Implementor <имя класса/интерфейса>
```

### Варианты:
- **Простой:** только интерфейсы, без generics.
- **Сложный:** интерфейсы и классы, без generics.
- **Бонус:** поддержка generics и корректная генерация типов.

## Домашнее задание 6. Jar Implementor

- Сборка `.jar`, содержащего `Implementor`.
- Поддержка запуска с `-jar` и генерации `.jar`-файла реализации.

**Необходимое:**
- Скрипт сборки jar и манифест.
- Исполняемый `.jar`.
- Поддержка модулей — для сложного варианта.

## Домашнее задание 7. Javadoc

Документируйте `Implementor` и его классы.

**Требования:**
- Документация всех классов и членов, включая `private`.
- Javadoc без предупреждений.
- Генерация ссылок на стандартные и курс-связанные классы.

## Домашнее задание 8. Итеративный параллелизм

Класс `IterativeParallelism` — многопоточная обработка списков.

### Методы простого варианта:
- `argMax`, `argMin`, `indexOf`, `lastIndexOf`, `sumIndices`

### Методы сложного варианта:
- `indices`, `filter`, `map`

**Ограничения:**
- Без `Concurrency Utilities` и `Parallel Streams`.
- `threads` — число потоков.

## Домашнее задание 9. Параллельный запуск

Класс `ParallelMapperImpl` реализует интерфейс `ParallelMapper`:

```java
public interface ParallelMapper extends AutoCloseable {
    <T, R> List<R> map(Function<? super T, ? extends R> f, List<? extends T> args) throws InterruptedException;
    @Override void close();
}
```

- Поддержка очереди заданий.
- Нет активного ожидания.
- Исключения не убивают потоки.
- Сложный вариант: пробрасывание исключений.
- Код в пакете `iterative`.

## Домашнее задание 10. Web Crawler

Реализуйте потокобезопасный `WebCrawler`:

```java
public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)
```

- `downloaders` — макс. число одновременно скачиваемых страниц.
- `extractors` — макс. число потоков извлечения ссылок.
- `perHost` — ограничение на число одновременных загрузок с одного хоста.